<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,user-scalable=no,minimum-scale=1.0,maximum-scale=1.0">
<meta name=description
	content="Real-time interactive 3D graphics in your browser using the WebGL and the Three.js JavaScript library">
<meta name=keywords content="Three.js,WebGL,JavaScript,GitHub,FOSS,3D,STEM">
<meta name=version content="2020-04-03">


<title></title>

<style>

/* Copyright 2020 Theo Armour. MIT License */

:root { font: 100% monospace; }

* { box-sizing: border-box; }

body { margin: 0; overflow: hidden; }

a { color: crimson; text-decoration: none; }
a:hover, a:focus, a:active { background-color: yellow; color: #aaa; text-decoration: underline; }

button { background-color: #ddd; border: none; border-radius: 2px; color: #322;cursor: pointer; padding: 3px 5px; }
button:hover { background: #ccc; color: #fff }

input[ type=range ] { -webkit-appearance: none; -moz-appearance: none; background-color: #ddd; border-radius: 2px; height: 1.7ch; width: 100%; }
input[ type=range ]::-moz-range-thumb { background-color: #888; border-radius: 2; width: 10px; }
input[ type=range ]::-webkit-slider-thumb { -webkit-appearance: none; background-color: #888; height: 18px; width: 10px; }

.help { float: right; }

.couponcode { float: right }

.couponcode:hover>.coupontooltip { display: block; }

.coupontooltip { border: 0.8ch double #888; background: white; display: none;
	font: 100% monospace; font-size: 1rem; font-weight: normal; /* unset summary settings */
	margin-left: -20ch; padding: 10px; position: absolute; z-index: 1000; }

#navMenu { margin: 0 20px; max-width: 15rem; position: absolute; }


#DMTdivParent {
	border: 1px solid#444;
	border-radius: 1rem 1rem 0 1rem;
	box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.9), 0 6px 20px 0 rgba(0, 0, 0, 0.6);
	height: 30ch;
	overflow: hidden;
	position: absolute;
	left: calc( 50% - 25ch );
	resize: both;
	top: 50%;
	/* transform: translate(-50% , -50%); */
	width: 50ch;
}

#DMTdivHeader {
	background-color: #ccc;
	cursor: move;
	padding: 1ch;
	user-select: none;
}

#DMTdivContainer {
	background-color: white;
	height: calc( 100% - 4ch );
	overflow: auto;
	padding: 1ch;
}


</style>

</head>

<body>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r114/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r114/examples/js/controls/OrbitControls.js"></script>

<nav id="navMenu">

	<header id="hdrTitle">

		<h2>
			<a id=aSource target=_top title="Source code on GitHub" >
				<img id=imgIcon height=18 style=opacity:0.5; >
			</a>

			<a href="" title="Click to reload this page" >
				<span id=sTitle ></span>
				<span id=sVersion ></span>
			</a>

			<span class="couponcode" >??<span id=divDescription class="coupontooltip" ></span></span>

		</h2>

	</header>

	<p>
		<button onclick="addMeshes()">add meshes</button>
	</p>


	<p>
		<button onclick=controls.reset() >reset view</button>
		<button onclick="sceneRotation = sceneRotation === 1 ? 0 : 1;">rotation</button>
	</p>

	<p>
		<output id=outSpeed>50</output>
		<input type="range" id="inpSpeed" onclick="sceneRotation=0.05 * this.value;outSpeed.innerHTML=this.value;" />
	</p>

	<div id="divLog"></div>

</nav>



<div id=DMTdivParent>

	<div id=DMTdivHeader title="Click this title bar to move this window" >
		Drag me
		<span onclick=DMTdivParent.hidden=true; title="Close this window" style=float:right>[ x ]</span>
	</div>

	<div id=DMTdivContainer >

		<div id=DMTdivContent>
			lorem ipsum, quia dolor sit, amet, consectetur, adipisci velit, sed quia non numquam eius
			modi tempora incidunt, ut labore et dolore magnam aliquam quaerat voluptatem. ut enim ad minima veniam, quis
			nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? quis
			autem vel eum iure reprehenderit, qui in ea voluptate velit esse, quam nihil molestiae consequatur, vel
			illum, qui dolorem eum fugiat, quo voluptas nulla pariatur?
		</div>

	</div>

</div>

<script>



let txt = "<p style='border:1px solid red;' >lorem ipsum, quia dolor sit, amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt, ut labore et dolore magnam aliquam quaerat voluptatem. ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? quis autem vel eum iure reprehenderit, qui in ea voluptate velit esse, quam nihil molestiae consequatur, vel illum, qui dolorem eum fugiat, quo voluptas nulla pariatur?</p>";

aSource.href = "https://github.com/zzzzz/xxxxx.html";
imgIcon.src = "https://pushme-pullyou.github.io/github-mark-32.png";

sTitle.innerHTML= document.title ? document.title : location.href.split( '/' ).pop().slice( 0, - 5 ).replace( /-/g, ' ' );
const version = document.head.querySelector( "[ name=version ]" );
sVersion.innerHTML = version ? version.content : "";
divDescription.innerHTML = document.head.querySelector( "[ name=description ]" ).content;


let mesh, group, axesHelper, lightDirectional, cameraHelper;
let sceneRotation = 1;
let renderer, camera, controls, scene;




function init() {

	camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
	camera.position.set( - 100, - 100, 100 );
	camera.up.set( 0, 0, 1 );

	scene = new THREE.Scene();
	scene.background = new THREE.Color( 0xcce0ff );
	//scene.fog = new THREE.Fog( 0xcce0ff, 550, 800 );
	scene.add( camera )

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );
	renderer.outputEncoding = THREE.sRGBEncoding;
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;

	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.maxDistance = 500;
	//controls.rotateSpeed = 2;
	controls.autoRotate = true;

	//controls.maxPolarAngle = Math.PI * 0.5;


	window.addEventListener( 'resize', onWindowResize, false );
	window.addEventListener( 'orientationchange', onWindowResize, false );
	window.addEventListener( 'keyup', () => sceneRotation = 0, false );
	renderer.domElement.addEventListener( 'click', () => sceneRotation = 0, false );

	addLights();

	axesHelper = new THREE.AxesHelper( 100 );
	scene.add( axesHelper );

	addGround();

	//addMesh();

	addMeshes();

	zoomObjectBoundingSphere();



	window.addEventListener( 'keydown', onStart );

	renderer.domElement.addEventListener( 'mousedown', onStart );
	//renderer.domElement.addEventListener( 'mousemove', onStart );
	renderer.domElement.addEventListener( 'wheel', onStart );

	renderer.domElement.addEventListener( 'touchstart', onStart );
	renderer.domElement.addEventListener( 'touchmove', onStart );
	renderer.domElement.addEventListener( 'touchend', onStart );


	DMTdivContent.innerHTML = `
	<b> ${ new Date() }</b>
	<p title="Or press any key or mousewheel to stop rotation">Click to stop rotation and start tracker</p>
	<p> ${ document.head.querySelector( "[ name=description ]" ).content }</p>
	${ txt }`;

	DMTdivHeader.addEventListener( "mousedown", DMT.onMouseDown );

}

function onStart () {

	controls.autoRotate = false;

	window.removeEventListener( 'keydown', onStart );

	renderer.domElement.removeEventListener( 'mousedown', onStart );
	//renderer.domElement.removeEventListener( 'mousemove', onStart );
	renderer.domElement.removeEventListener( 'wheel', onStart );

	renderer.domElement.removeEventListener( 'touchstart', onStart );
	renderer.domElement.removeEventListener( 'touchmove', onStart );
	renderer.domElement.removeEventListener( 'touchend', onStart );

	DMT.init();

};

// https://redstapler.co/4-ways-to-center-div-css/



/* globals THREE, DMTdivContent, DMTdivParent, renderer, camera, group, txt */
// jshint esversion: 6
// jshint loopfunc: true

const DMT = {};

DMT.x = 0;
DMT.y = 0;
DMT.intersected = undefined;



DMT.init = function () {

	DMTdivParent.hidden = true;

	renderer.domElement.addEventListener( "mouseover", DMT.onEvent );
	renderer.domElement.addEventListener( "touchstart", DMT.onEvent );

	DMT.onEvent(); // for mouse

};



DMT.onEvent = function( e ) {
	console.log( '', e );

	renderer.domElement.addEventListener( "touchmove", DMT.onMove );
	renderer.domElement.addEventListener( "touchend", DMT.onOut );
	renderer.domElement.addEventListener( 'mousemove', DMT.onMove );
	renderer.domElement.addEventListener( 'mouseout', DMT.onOut );

	DMT.onMove( e ); // for touch

};



DMT.onMove = function( e ) {
	//console.log( 'e move', e );

	if ( e ) { DMT.checkIntersect ( e ); }

};



DMT.onMouseOverOut = function () {

	renderer.domElement.removeEventListener( "touchmove", DMT.onMove );
	renderer.domElement.removeEventListener( "touchend", DMT.onOut );
	renderer.domElement.removeEventListener( 'mousemove', DMT.onMove );
	renderer.domElement.removeEventListener( 'mouseup', DMT.onOut );

};



DMT.checkIntersect = function ( event ) {
	console.log( 'event chkInt ', event );

	if ( event.type === "touchmove" || event.type === "touchstart" ) {

		event.clientX = event.touches[ 0 ].clientX;
		event.clientY = event.touches[ 0 ].clientY;

	}

	const mouse = new THREE.Vector2();
	mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

	const raycaster = new THREE.Raycaster();
	raycaster.setFromCamera( mouse, camera );

	const intersects = raycaster.intersectObjects( group.children );

	if ( intersects.length > 0 ) {

		if ( DMT.intersected !== intersects[ 0 ].object ) {

			DMT.intersected = intersects[ 0 ].object;
			//console.log( 'int', DMT.intersected );

			DMTdivParent.hidden = false;
			DMTdivParent.style.left = event.clientX + "px";
			DMTdivParent.style.top = event.clientY + "px";

			DMTdivContent.innerHTML = `
			<p>${ event.clientX } ${ event.clientY }
			<p>${ DMT.intersected.name }
			${ txt }`;


		}

	} else {

		// DMT.intersected = null;
		// DMTdivParent.hidden = true;
		// DMTdivContent.innerHTML = "";
	}

};




DMT.onMouseDown = function ( e ) {
	//console.log( 'm down', e );

	DMTdivHeader.addEventListener( "touchmove", DMT.onMouseDownMove );
	DMTdivHeader.addEventListener( "touchend", DMT.onMouseDownOut );
	DMTdivHeader.addEventListener( 'mousemove', DMT.onMouseDownMove );
	DMTdivHeader.addEventListener( 'mouseup', DMT.onMouseDownOut );

	DMT.onMouseDownMove( e ); // for touch


};

DMT.onMouseDownMove = function( e ) {

	let dx, dy;

	if ( e.type === "touchmove" ) {

		dx = e.touches[ 0 ].clientX - DMT.x;
		dy = e.touches[ 0 ].clientY - DMT.y;

		DMT.x = e.touches[ 0 ].clientX;
		DMT.y = e.touches[ 0 ].clientY;

	} else {

		dx = e.clientX - DMT.x;
		dy = e.clientY - DMT.y;

		DMT.x = e.clientX;
		DMT.y = e.clientY;

	}

	//DMTdivParent.style.left = DMTdivHeader.offsetLeft + dx + "px";
	//DMTdivParent.style.top = DMTdivHeader.offsetTop + dy + "px";

	DMTdivParent.style.left = ( event.clientX - 15 ) + "px";
	DMTdivParent.style.top = ( event.clientY - 15 ) + "px";

}

DMT.onMouseDownOut = function() {

	DMTdivHeader.removeEventListener( "touchmove", DMT.onMouseDownMove );
	DMTdivHeader.removeEventListener( "touchend", DMT.onMouseDownOut );
	DMTdivHeader.removeEventListener( 'mousemove', DMT.onMouseDownMove );
	DMTdivHeader.removeEventListener( 'mouseup', DMT.onMouseDownOut );



}

//////////

function addLights() {

	//scene.add( new THREE.AmbientLight( 0x404040 ) );
	scene.add( new THREE.AmbientLight( 0x666666 ) );

	const pointLight = new THREE.PointLight( 0xffffff, 0.2 );
	pointLight.position.copy( camera.position );
	camera.add( pointLight );

	lightDirectional = new THREE.DirectionalLight( 0xdffffff, 0.5 );
	lightDirectional.position.set( -50, -200, 100 );
	lightDirectional.castShadow = true;
	lightDirectional.shadow.mapSize.width = 1024;
	lightDirectional.shadow.mapSize.height = 1024;

	var d = 100;
	lightDirectional.shadow.camera.left = - d;
	lightDirectional.shadow.camera.right = d;
	lightDirectional.shadow.camera.top = d;
	lightDirectional.shadow.camera.bottom = - d;
	lightDirectional.shadow.camera.far = 500;
	scene.add( lightDirectional );

	scene.add( new THREE.CameraHelper( lightDirectional.shadow.camera ) );

}



function addGround() {

	const geometry = new THREE.PlaneBufferGeometry( 2000, 2000 );
	const material = new THREE.MeshPhongMaterial( { color: 0xaaaaaa, depthWrite: false, side: 2 } );
	const mesh = new THREE.Mesh( geometry, material );
	mesh.position.z = -50;
	mesh.receiveShadow = true;
	scene.add( mesh );

}



function zoomObjectBoundingSphere( obj = group ) {
	//console.log( "obj", obj );

	center = new THREE.Vector3( 0, 0, 0 );
	radius=  50;

	const bbox = new THREE.Box3().setFromObject( obj );
	//console.log( 'bbox', bbox );

	if ( bbox.max.x !== Infinity ) {

		const sphere = bbox.getBoundingSphere( new THREE.Sphere() );

		center = sphere.center;
		radius = sphere.radius;
		//console.log( "sphere", sphere )
	}

	controls.target.copy( center ); // needed because model may be far from origin
	controls.maxDistance = 50 * radius;

	delta = camera.position.clone().sub( controls.target ).normalize();
	//console.log( 'delta', delta );

	position = controls.target.clone().add( delta.multiplyScalar( 2 * radius ) );
	//console.log( 'position', position );

	distance = controls.target.distanceTo( camera.position );

	//camera.zoom = distance / (  * radius ) ;

	camera.position.copy( center.clone().add( new THREE.Vector3( -2 * radius, 2 * radius, 1.0 * radius ) ) );
	camera.near = 0.001 * radius; //2 * camera.position.length();
	camera.far = 50 * radius; //2 * camera.position.length();
	camera.updateProjectionMatrix();

	axesHelper.position.copy( center );

	if ( lightDirectional ) {

		lightDirectional.position.copy( center.clone().add( new THREE.Vector3( -1.5 * radius, 1.5 * radius, 1.5 * radius ) ) );
		lightDirectional.shadow.camera.scale.set( 0.02 * radius, 0.02 * radius, 0.2 * radius );

		//targetObject.position.copy( center );

		scene.remove( cameraHelper );
		cameraHelper = new THREE.CameraHelper( lightDirectional.shadow.camera );
		scene.add( cameraHelper );

	}

	let event = new Event( "onresetthree", {"bubbles": true, "cancelable": false, detail: true } );

	//window.addEventListener( "onrresetthree", doThings, false );

	// listening: or-object-rotation-xx.js
	// listening: dss-display-scene-settings-xx.js

	window.dispatchEvent( event );

};



function addMesh( size = 5 ) {

	// CylinderGeometry( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded )
	// SphereGeometry( radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength )
	// TorusGeometry( radius, tube, radialSegments, tubularSegments, arc )

	const geometry = new THREE.BoxGeometry( size, size, size );

	geometry.applyMatrix4( new THREE.Matrix4().makeRotationX( -0.5 * Math.PI ) );
	geometry.applyMatrix4( new THREE.Matrix4().makeScale( 1, 1, 1 ) );
	geometry.applyMatrix4( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );

	//const material = new THREE.MeshNormalMaterial();
	const material = new THREE.MeshPhongMaterial( { color: 0xffffff * Math.random(), specular: 0xffffff } );
	mesh = new THREE.Mesh( geometry, material );
	mesh.receiveShadow = true;
	mesh.castShadow = true;
	scene.add( mesh );

	return mesh;

}



function addMeshes( count = 100 ) {

	scene.remove( group );

	group = new THREE.Group();

	for ( let i = 0; i < count; i++ ) { group.add( addMesh() ) };

	group.children.forEach( ( mesh, index ) => {
		mesh.position.set( Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50 );
		mesh.rotation.set( 0.2 * Math.random(), 0.2 * Math.random(), 0.2 * Math.random() );
		mesh.name = `mesh: ${ index }`;
	} );

	scene.add( group );

	zoomObjectBoundingSphere( group )

}



function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

	controls.handleResize();

	//console.log( 'onWindowResize  window.innerWidth', window.innerWidth );

}



function animate() {

	requestAnimationFrame( animate );
	renderer.render( scene, camera );
	controls.update();
	//group.rotation.z += sceneRotation / 1000;

}


init();
animate();

</script>
</body>
</html>